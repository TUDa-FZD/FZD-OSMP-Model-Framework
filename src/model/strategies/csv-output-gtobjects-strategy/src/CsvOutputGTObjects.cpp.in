//
// Copyright Institute of Automotive Engineering
// of Technical University of Darmstadt 2020.
// Licensed under the EUPL-1.2-or-later
//
// This work covered by the EUPL can be used/merged and distributed
// in other works covered by GPL-2.0, GPL-3.0, LGPL, AGPL, CeCILL,
// OSL, EPL, MPL and other licences listed as compatible in the EUPL
// Appendix. This applies to the other (combined) work, while the
// original project stays covered by the EUPL without re-licensing.
//
// Alternatively, the contents of this file may be used under the
// terms of the Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, you can obtain one at
// http://mozilla.org/MPL/2.0/.
//

#ifndef _USE_MATH_DEFINES
#define _USE_MATH_DEFINES
#endif

#include "csvoutputgtobjects/CsvOutputGTObjects.hpp"
#include <fstream>
#include <iostream>
#include <vector>

#ifdef _WIN32
#include <math.h>
#else
#include <cmath>
#endif

using namespace model;
using namespace osi3;

static bool first_call = true;

void model::CsvOutputGTObjects::apply(SensorData &sensor_data) {
    log("Starting .csv output for GT objects");

    std::string csv_path = "@CSV_PATH@";
//    boost::filesystem::create_directory(csv_path);
    std::string filename = "@MODEL_NAME@_GTObjects.csv";
    std::string path = csv_path + "/" + filename;

    /// Write header line of .csv on first call
    if (first_call){
        write_first_line_to_CSV(path);
        first_call = false;
    }

    if (!sensor_data.sensor_view(0).global_ground_truth().has_host_vehicle_id())
        alert("Ego vehicle has no base, no id, or is not contained sensor_data GT moving objects.");

    if (sensor_data.sensor_view(0).has_global_ground_truth()) {

        auto time_nanos = sensor_data.sensor_view(0).global_ground_truth().timestamp().nanos();
        auto time_seconds = sensor_data.sensor_view(0).global_ground_truth().timestamp().seconds();
        double timestamp = (double)time_seconds + (double) time_nanos / 1000000000;

        uint64_t no_of_moving_objects = sensor_data.sensor_view(0).global_ground_truth().moving_object_size();
        uint64_t no_of_stationary_objects = sensor_data.sensor_view(0).global_ground_truth().stationary_object_size();

        /// Start a vector for gt_objects with (gt_id, x, y, z, roll, pitch, yaw, width, length, height, is_moving)
        std::vector< std::pair<uint64_t, std::pair<float, std::pair<float, std::pair<float, std::pair<float, std::pair<float, std::pair<float, std::pair<float, std::pair<float, std::pair<float, bool> > > > > > > > > > > gt_objects;
        gt_objects.reserve(no_of_moving_objects + no_of_stationary_objects);

        if ((sensor_data.sensor_view(0).global_ground_truth().moving_object_size() > 0) || (sensor_data.sensor_view(0).global_ground_truth().stationary_object_size() > 0)) {
            /// Collect moving objects
            for (const auto &gt_moving_object : sensor_data.sensor_view(0).global_ground_truth().moving_object()) {
                if (gt_moving_object.id().value() == sensor_data.sensor_view(0).global_ground_truth().host_vehicle_id().value()) {
                    continue;
                }
                gt_objects.emplace_back(std::make_pair(gt_moving_object.id().value(),
                                                       std::make_pair((float) gt_moving_object.base().position().x(),
                                                                      std::make_pair((float) gt_moving_object.base().position().y(),
                                                                                     std::make_pair((float) gt_moving_object.base().position().z(),
                                                                                                    std::make_pair((float) gt_moving_object.base().orientation().roll(),
                                                                                                                   std::make_pair((float) gt_moving_object.base().orientation().pitch(),
                                                                                                                                  std::make_pair((float) gt_moving_object.base().orientation().yaw(),
                                                                                                                                                 std::make_pair((float) gt_moving_object.base().dimension().width(),
                                                                                                                                                                std::make_pair((float) gt_moving_object.base().dimension().length(),
                                                                                                                                                                               std::make_pair((float) gt_moving_object.base().dimension().height(),
                                                                                                                                                                                              true)))))))))));
            }

            /// Collect stationary objects
            for (const auto &gt_stationary_object : sensor_data.sensor_view(0).global_ground_truth().stationary_object()) {
                gt_objects.emplace_back(std::make_pair(gt_stationary_object.id().value(),
                                                       std::make_pair((float) gt_stationary_object.base().position().x(),
                                                                      std::make_pair((float) gt_stationary_object.base().position().y(),
                                                                                     std::make_pair((float) gt_stationary_object.base().position().z(),
                                                                                                    std::make_pair((float) gt_stationary_object.base().orientation().roll(),
                                                                                                                   std::make_pair((float) gt_stationary_object.base().orientation().pitch(),
                                                                                                                                  std::make_pair((float) gt_stationary_object.base().orientation().yaw(),
                                                                                                                                                 std::make_pair((float) gt_stationary_object.base().dimension().width(),
                                                                                                                                                                std::make_pair((float) gt_stationary_object.base().dimension().length(),
                                                                                                                                                                               std::make_pair((float) gt_stationary_object.base().dimension().height(),
                                                                                                                                                                                              false)))))))))));
            }

            for (const auto & gt_object : gt_objects) {
                auto gt_id = gt_object.first;

                auto x = std::round(gt_object.second.first * 1000) / 1000;
                auto y = std::round(gt_object.second.second.first * 1000) / 1000;
                auto z = std::round(gt_object.second.second.second.first * 1000) / 1000;

                auto roll  = (float)std::round(gt_object.second.second.second.second.first * 180 / M_PI * 1000) / 1000;
                auto pitch = (float)std::round(gt_object.second.second.second.second.second.first * 180 / M_PI * 1000) / 1000;
                auto yaw   = (float)std::round(gt_object.second.second.second.second.second.second.first * 180 / M_PI * 1000) / 1000;

                auto width  = gt_object.second.second.second.second.second.second.second.first;
                auto length = gt_object.second.second.second.second.second.second.second.second.first;
                auto height = gt_object.second.second.second.second.second.second.second.second.second.first;

                auto is_moving = gt_object.second.second.second.second.second.second.second.second.second.second;

                write_data_to_CSV(path, timestamp, gt_id, x, y, z, roll, pitch, yaw, width, length, height, is_moving);
            }

        } else {
            log("No objects sensor_data GT for .csv output at timestamp " + std::to_string(timestamp));
        }
    } else {
        auto timestamp = (double) sensor_data.sensor_view(0).global_ground_truth().timestamp().seconds() + (double) sensor_data.sensor_view(0).global_ground_truth().timestamp().nanos() / 1000000000;
        log("No GT for .csv output at timestamp " + std::to_string(timestamp));
    }
}

void CsvOutputGTObjects::write_first_line_to_CSV(const std::string& path) {
    std::fstream my_file;
    my_file.open(path, std::ios::app);
    my_file << "timestamp_in_s, gt_object_id, x_in_m, y_in_m, z_in_m, roll_in_deg, pitch_in_deg, yaw_in_deg, width_in_m, length_in_m, height_in_m, is_moving" << std::endl;
    my_file.close();
}

void CsvOutputGTObjects::write_data_to_CSV(const std::string& path, double timestamp, uint64_t object_idx, float x, float y, float z, float roll, float pitch, float yaw, float width, float length, float height, bool is_moving) {
    std::fstream my_file;
    my_file.open(path, std::ios::app);
    my_file << timestamp << ", " << object_idx << ", " << x << ", " << y << ", " << z << ", " << roll << ", " << pitch << ", " << yaw << ", " << width << ", " << length << ", " << height << ", " << (is_moving ? "true": "false") << std::endl;
    my_file.close();
}